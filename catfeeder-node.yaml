esphome:
  name: catfeeder-node
  friendly_name: catfeeder-node

esp32:
  board: nodemcu-32s
  framework:
    type: arduino

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  services:
    - service: feed_cat
      then:
      - script.execute:
          id: feed_script
          force: true
          servings_current: 1

web_server:
  port: 80

ota:
  password: "c77a50f9d929caf56146ed0e31b0d93b"
  platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Catfeeder-Node Fallback Hotspot"
    password: !secret wifi_fallback_password

captive_portal:
 
output:
  - platform: ledc
    pin: GPIO23
    # frequency: 1000 Hz
    id: pwm_output
  - platform: ledc
    pin: GPIO22
    # frequency: 1000 Hz
    id: pwm_output2
  # - platform: ledc
  #   pin: GPIO4
  #   frequency: 1000 Hz
  #   id: motor_enable

fan:
  - platform: hbridge
    id: serving_motor
    name: "Cat Feeder"
    pin_a: pwm_output
    pin_b: pwm_output2
    # enable_pin: motor_enable
    # decay_mode: slow
    # internal: True
    restore_mode: ALWAYS_OFF 
    on_turn_on:
      - fan.turn_on: 
          id: serving_motor
          speed: 100

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO15
      mode:
        input: true
        pullup: true
      inverted: true
    id: feed_clicker
    name: "Feed Clicker"
    internal: True

switch:
  - platform: restart
    name: "Cat Feeder Restart"
  - platform: template
    name: "Cat Feeder Test Mode"
    id: cat_feeder_test_mode
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Skip Next Meal"
    id: skip_next_meal
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF

number:
  - platform: template
    id: max_servings_per_day
    name: "Max Servings per day"
    optimistic: true
    min_value: 1
    max_value: 20
    restore_value: True
    initial_value: 12
    step: 1
  - platform: template
    name: "Servings today"
    id: servings_today
    optimistic: true
    min_value: 0
    max_value: 100
    restore_value: True
    initial_value: 0
    step: 1
    internal: true
    on_value:
      then:
      - sensor.template.publish:
          id: servings_today_sensor
          state: !lambda 'return x;'
  - platform: template
    name: "Servings total"
    id: servings_total
    optimistic: true
    min_value: 0
    max_value: 1000000
    restore_value: True
    initial_value: 0
    step: 1
    internal: true
    on_value:
      then:
      - sensor.template.publish:
          id: servings_total_sensor
          state: !lambda 'return x;'
  - platform: template
    name: "Active servings"
    id: active_servings
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    on_value:
      then:
      - sensor.template.publish:
          id: active_servings_sensor
          state: !lambda return x;
  - platform: template
    name: "Bonus treats internal"
    id: bonus_treats_internal
    optimistic: true
    min_value: 0
    max_value: 10
    restore_value: True
    step: 1
    internal: true
  - platform: template
    name: "Feed Schedule 1 Time (min)"
    id: feed_schedule_1_time_min
    optimistic: true
    min_value: 0
    max_value: 1440
    step: 1
    restore_value: True
    initial_value: 420
  - platform: template
    name: "Feed Schedule 1 Amount (servings)"
    id: feed_schedule_1_amount
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    restore_value: True
    initial_value: 5
  - platform: template
    name: "Feed Schedule 2 Time (min)"
    id: feed_schedule_2_time_min
    optimistic: true
    min_value: 0
    max_value: 1440
    step: 1
    restore_value: True
    initial_value: 960
  - platform: template
    name: "Feed Schedule 2 Amount (servings)"
    id: feed_schedule_2_amount
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    restore_value: True
    initial_value: 5
  - platform: template
    name: "Feed Schedule 3 Time (min)"
    id: feed_schedule_3_time_min
    optimistic: true
    min_value: 0
    max_value: 1440
    step: 1
    restore_value: True
    initial_value: 1260
  - platform: template
    name: "Feed Schedule 3 Amount (servings)"
    id: feed_schedule_3_amount
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    restore_value: True
    initial_value: 5
  - platform: template
    name: "Feed Schedule 4 Time (min)"
    id: feed_schedule_4_time_min
    optimistic: true
    min_value: 0
    max_value: 1440
    step: 1
    restore_value: True
    initial_value: 0
  - platform: template
    name: "Feed Schedule 4 Amount (servings)"
    id: feed_schedule_4_amount
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    restore_value: True
    initial_value: 0

globals:
  - id: daily_reset_last_day
    type: int
    restore_value: yes
    initial_value: '-1'
  - id: scheduler_last_minute
    type: int
    restore_value: no
    initial_value: '-1'

interval:
  - interval: 10s
    then:
      - lambda: |-
          auto now = id(sntp_time).now();
          if (!now.is_valid()) return;

          const int current_min = now.hour * 60 + now.minute;
          const int day_key = now.year * 10000 + now.month * 100 + now.day_of_month;

          // Daily reset (whenever we notice the day changed)
          if (id(daily_reset_last_day) != day_key) {
            id(daily_reset_last_day) = day_key;
            id(servings_today).publish_state(0);
            id(bonus_treats_internal).publish_state(0);
          }

          // Only evaluate schedules once per minute (even though this runs every 10s)
          if (id(scheduler_last_minute) == current_min) return;
          id(scheduler_last_minute) = current_min;

          auto maybe_run = [&](int time_min, int amount) {
            if (amount <= 0) return;
            if (time_min < 0 || time_min > 1440) return;
            const int normalized_time = (time_min >= 1440) ? 0 : time_min;
            if (normalized_time != current_min) return;
            id(feed_script).execute(amount, false);
          };

          maybe_run((int) id(feed_schedule_1_time_min).state, (int) id(feed_schedule_1_amount).state);
          maybe_run((int) id(feed_schedule_2_time_min).state, (int) id(feed_schedule_2_amount).state);
          maybe_run((int) id(feed_schedule_3_time_min).state, (int) id(feed_schedule_3_amount).state);
          maybe_run((int) id(feed_schedule_4_time_min).state, (int) id(feed_schedule_4_amount).state);

script:
  - id: feed_script
    mode: restart
    parameters:
      servings_current: int
      force: bool
    then:
      - if:
          condition:
            switch.is_on: cat_feeder_test_mode
          then:
            - logger.log:
                format: "TEST MODE: would feed %d servings (force=%d)"
                args: [ 'servings_current', 'force' ]
                level: INFO
            - text_sensor.template.publish:
                id: last_feed
                state: !lambda |-
                  auto timeSting = id(sntp_time).now().strftime("%c");
                  return std::string("TEST MODE @ ") + timeSting;
            - if:
                condition:
                  lambda: !lambda return !force;
                then:
                  - logger.log: "TEST MODE: resetting skip next meal"
                  - switch.template.publish:
                      id: skip_next_meal
                      state: OFF
            - script.stop: feed_script
      - if:
          condition:
            - or:
              - lambda: !lambda return force;
              - and:
                - lambda: !lambda return int(id(servings_today).state) < int(id(max_servings_per_day).state);
                - switch.is_off: skip_next_meal
          then:
            - number.set:
                id: active_servings
                value: !lambda 'return servings_current;'
            - while:
                condition:
                  lambda: |-
                    return id(active_servings).state > 0;
                then:
                  - if:
                      condition:
                        - lambda: !lambda return int(id(servings_today).state) >= int(id(max_servings_per_day).state);
                      then:
                        - logger.log:
                            format: "Max servigns reached= %f"
                            args: [ 'id(servings_today).state' ]
                            level: INFO
                        - number.decrement: active_servings
                      else:
                        - logger.log:
                            format: "Feeding meal active= %f, total= %f, skip=%d, max=%f, today=%f"
                            args: [ 'id(active_servings).state', 'id(active_servings).state', 'id(skip_next_meal).state', 'id(max_servings_per_day).state', 'id(servings_today).state']
                            level: INFO
                        - sensor.template.publish:
                            id: active_servings_sensor
                            state: !lambda 'return id(active_servings).state;'
                        - fan.turn_on: 
                            id: serving_motor
                        - if:
                            condition:
                              binary_sensor.is_on: feed_clicker
                            then:
                            - wait_until:
                                binary_sensor.is_off: feed_clicker
                            - wait_until:
                                binary_sensor.is_on: feed_clicker
                            - wait_until:
                                binary_sensor.is_off: feed_clicker
                            - fan.turn_off: serving_motor
                            else:
                            - wait_until:
                                binary_sensor.is_on: feed_clicker
                            - wait_until:
                                binary_sensor.is_off: feed_clicker
                            - fan.turn_off: serving_motor
                        - number.increment: servings_today
                        - number.increment: servings_total
                        - number.decrement: active_servings
                        - text_sensor.template.publish:
                            id: last_feed
                            state: !lambda |-
                              auto timeSting = id(sntp_time).now().strftime("%c");
                              return timeSting;
                        - delay: 300s
            - number.to_min: active_servings
      - if:
          condition:
            lambda: !lambda return !force;
          then:
          - logger.log: "Resetting skip next meal"
          - switch.template.publish:
              id: skip_next_meal
              state: OFF

button:
  - platform: template
    name: Feed Single
    id: feed_single
    on_press:
      then:
      - script.execute:
          id: feed_script
          force: true
          servings_current: 1
      - number.increment: bonus_treats_internal
  - platform: template
    name: Feed Meal
    id: feed_meal
    on_press:
      then:
      - switch.template.publish:
          id: skip_next_meal
          state: Off
      - script.execute:
          id: feed_script
          force: true
          servings_current: !lambda 'return (int) id(active_servings).state;'
      - switch.template.publish:
          id: skip_next_meal
          state: On

time:
  - platform: sntp
    id: sntp_time

text_sensor:
  - platform: template
    name: "Last feed"
    id: last_feed
  - platform: template
    name: "Feed schedule"
    lambda: !lambda |-
      auto fmt = [](int min_of_day) -> std::string {
        if (min_of_day < 0) min_of_day = 0;
        if (min_of_day > 1440) min_of_day = 1440;
        if (min_of_day >= 1440) min_of_day = 0;
        char buf[6];
        snprintf(buf, sizeof(buf), "%02d:%02d", min_of_day / 60, min_of_day % 60);
        return std::string(buf);
      };

      std::string out;
      auto add = [&](int idx, int time_min, int amount) {
        if (amount <= 0) return;
        if (!out.empty()) out += ", ";
        out += "#" + std::to_string(idx) + " " + fmt(time_min) + " (" + std::to_string(amount) + ")";
      };

      add(1, (int) id(feed_schedule_1_time_min).state, (int) id(feed_schedule_1_amount).state);
      add(2, (int) id(feed_schedule_2_time_min).state, (int) id(feed_schedule_2_amount).state);
      add(3, (int) id(feed_schedule_3_time_min).state, (int) id(feed_schedule_3_amount).state);
      add(4, (int) id(feed_schedule_4_time_min).state, (int) id(feed_schedule_4_amount).state);

      if (out.empty()) return std::string("(none)");
      return out;
  - platform: template
    name: "Next feed"
    update_interval: 30s
    lambda: !lambda |-
      auto now = id(sntp_time).now();
      if (!now.is_valid()) return std::string("(unknown)");

      const int current_min = now.hour * 60 + now.minute;
      const bool skip_next = id(skip_next_meal).state;

      struct Schedule {
        int time_min;
        int idx;
      };

      std::vector<Schedule> schedules;
      auto add = [&](int idx, int time_min, int amount) {
        if (amount <= 0) return;
        schedules.push_back({time_min, idx});
      };

      add(1, (int) id(feed_schedule_1_time_min).state, (int) id(feed_schedule_1_amount).state);
      add(2, (int) id(feed_schedule_2_time_min).state, (int) id(feed_schedule_2_amount).state);
      add(3, (int) id(feed_schedule_3_time_min).state, (int) id(feed_schedule_3_amount).state);
      add(4, (int) id(feed_schedule_4_time_min).state, (int) id(feed_schedule_4_amount).state);

      if (schedules.empty()) return std::string("(none)");

      std::sort(schedules.begin(), schedules.end(), [](const Schedule &a, const Schedule &b) {
        return a.time_min < b.time_min;
      });

      int found_index = -1;
      for (size_t i = 0; i < schedules.size(); i++) {
        if (schedules[i].time_min > current_min) {
          found_index = (int) i;
          break;
        }
      }
      if (found_index < 0) found_index = 0;

      if (skip_next) {
        found_index = (found_index + 1) % (int) schedules.size();
      }

      const int next_min = schedules[found_index].time_min;
      const int next_idx = schedules[found_index].idx;

      auto fmt12 = [](int min_of_day) -> std::string {
        if (min_of_day < 0) min_of_day = 0;
        if (min_of_day > 1440) min_of_day = 1440;
        if (min_of_day >= 1440) min_of_day = 0;
        int h = min_of_day / 60;
        int m = min_of_day % 60;
        std::string period = (h >= 12) ? "PM" : "AM";
        int hour12 = (h > 12) ? h - 12 : h;
        if (hour12 == 0) hour12 = 12;
        char buf[16];
        snprintf(buf, sizeof(buf), "%d:%02d %s", hour12, m, period.c_str());
        return std::string(buf);
      };

      return "S" + std::to_string(next_idx) + " " + fmt12(next_min);
sensor:
  - platform: template
    name: "Active Servings"
    id: active_servings_sensor
    state_class: "measurement"
  - platform: template
    name: "Servings today"
    id: servings_today_sensor
    state_class: "total_increasing"
  - platform: template
    id: servings_total_sensor
    name: "Servings total"
    state_class: "total"
  - platform: template
    name: "Bonus treats today"
    id: bonus_treats
    state_class: "measurement"
    lambda: !lambda |-
      return id(bonus_treats_internal).state;